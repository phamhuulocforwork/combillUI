{
  "name": "use-parse-csv",
  "type": "registry:hook",
  "registryDependencies": [],
  "dependencies": [
    "papaparse",
    "react"
  ],
  "devDependencies": [],
  "files": [
    {
      "path": "use-parse-csv.ts",
      "content": "import * as Papa from 'papaparse';\nimport * as React from 'react';\nimport { getErrorMessage } from '@/lib/handle-error';\n\ninterface CsvState {\n  fileName: string;\n  data: {\n    parsed: Record<string, unknown>[];\n    mapped: Record<string, unknown>[];\n  };\n  fieldMappings: {\n    original: Record<string, string | undefined>;\n    current: Record<string, string | undefined>;\n  };\n  error: string | null;\n}\n\ninterface UseParseCsvProps extends Papa.ParseConfig {\n  fields: { label: string; value: string; required?: boolean }[];\n  onSuccess?: (data: Record<string, unknown>[]) => void;\n  onError?: (message: string) => void;\n  showEmptyFields?: boolean;\n}\n\nexport function useParseCsv({\n  onSuccess,\n  onError,\n  showEmptyFields,\n  ...props\n}: UseParseCsvProps) {\n  const [csvState, setCsvState] = React.useState<CsvState>({\n    fileName: '',\n    data: {\n      parsed: [],\n      mapped: [],\n    },\n    fieldMappings: {\n      current: {},\n      original: {},\n    },\n    error: null,\n  });\n\n  function onParse({ file, limit = Infinity }: { file: File; limit?: number }) {\n    let count = 0;\n    const allResults: Record<string, unknown>[] = [];\n\n    Papa.parse<Record<string, unknown>>(file, {\n      ...props,\n      header: true,\n      dynamicTyping: true,\n      skipEmptyLines: true,\n      beforeFirstChunk: (chunk) => {\n        const parsedChunk = Papa.parse<string[]>(chunk, {\n          header: false,\n          skipEmptyLines: true,\n        });\n\n        const rows = parsedChunk.data;\n        const columns = rows[0] ?? [];\n\n        const newColumns = columns\n          .map((column, index) => {\n            if (column.trim() === '' && !showEmptyFields) {\n              const hasNonEmptyValue = rows\n                .slice(1)\n                .some(\n                  (row) =>\n                    row[index] !== '' &&\n                    row[index] !== null &&\n                    row[index] !== undefined,\n                );\n              if (!hasNonEmptyValue) {\n                return null;\n              }\n            }\n            return column.trim() === '' ? `Field ${index + 1}` : column;\n          })\n          .filter((column) => column !== null);\n\n        rows[0] = newColumns;\n        return Papa.unparse(rows);\n      },\n      step: (results, parser) => {\n        try {\n          if (count === 0) {\n            const mappings = (results.meta.fields ?? [])?.reduce(\n              (acc, field) => ({\n                ...acc,\n                [field]: field,\n              }),\n              {},\n            );\n\n            setCsvState((prevState) => ({\n              ...prevState,\n              fieldMappings: {\n                original: mappings,\n                current: mappings,\n              },\n            }));\n          }\n\n          if (count < limit) {\n            allResults.push(results.data);\n            count++;\n          } else {\n            parser.abort();\n            throw new Error(`Only ${limit} rows are allowed`);\n          }\n        } catch (err) {\n          const message = getErrorMessage(err);\n          setCsvState((prevState) => ({ ...prevState, error: message }));\n          onError?.(message);\n        }\n      },\n      complete: (_, localFile: File) => {\n        setCsvState((prevState) => ({\n          ...prevState,\n          fileName: localFile?.name\n            ? localFile.name.replace(/\\.[^/.]+$/, '')\n            : 'Untitled',\n          data: {\n            parsed: allResults,\n            mapped: allResults,\n          },\n        }));\n        onSuccess?.(allResults);\n      },\n    });\n  }\n\n  function onFieldChange({\n    oldValue,\n    newValue,\n  }: {\n    oldValue: string;\n    newValue: string;\n  }) {\n    setCsvState((prevState) => ({\n      ...prevState,\n      fieldMappings: {\n        ...prevState.fieldMappings,\n        current: { ...prevState.fieldMappings.current, [newValue]: oldValue },\n      },\n      data: {\n        ...prevState.data,\n        mapped: prevState.data.mapped.map((row, index) => ({\n          ...row,\n          [newValue]: prevState.data.parsed[index]?.[oldValue],\n        })),\n      },\n    }));\n  }\n\n  function onFieldToggle({\n    value,\n    checked,\n  }: {\n    value: string;\n    checked: boolean;\n  }) {\n    setCsvState((prevState) => ({\n      ...prevState,\n      fieldMappings: {\n        ...prevState.fieldMappings,\n        current: {\n          ...prevState.fieldMappings.current,\n          [value]: checked ? '' : undefined,\n        },\n      },\n      data: {\n        ...prevState.data,\n        mapped: prevState.data.mapped.map((row) => {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { [value]: _, ...rest } = row;\n          return rest;\n        }),\n      },\n    }));\n  }\n\n  function onFieldsReset() {\n    setCsvState((prevState) => ({\n      ...prevState,\n      fieldMappings: {\n        ...prevState.fieldMappings,\n        current: prevState.fieldMappings.original,\n      },\n      data: {\n        ...prevState.data,\n        mapped: prevState.data.parsed,\n      },\n    }));\n  }\n\n  function getSanitizedData({ data }: { data: Record<string, unknown>[] }) {\n    return data.map((row) =>\n      Object.keys(row).reduce(\n        (acc, key) => ({\n          ...acc,\n          [key]: row[key] === null ? '' : row[key],\n        }),\n        {},\n      ),\n    );\n  }\n\n  return {\n    fileName: csvState.fileName,\n    data: csvState.data.mapped,\n    fieldMappings: csvState.fieldMappings,\n    error: csvState.error,\n    getSanitizedData,\n    onParse,\n    onFieldChange,\n    onFieldToggle,\n    onFieldsReset,\n  };\n}\n",
      "type": "registry:hook"
    }
  ]
}