{
  "name": "code-editor",
  "type": "registry:ui",
  "registryDependencies": [],
  "dependencies": [
    "react",
    "shiki"
  ],
  "devDependencies": [],
  "tailwind": {},
  "cssVars": {
    "light": {},
    "dark": {}
  },
  "files": [
    {
      "path": "code-editor.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport type { HTMLAttributes } from \"react\";\n\nimport { createHighlighter } from \"shiki\";\n\nimport { cn } from \"@/lib/utils\";\n\nexport interface CodeEditorProps\n  extends Omit<HTMLAttributes<HTMLTextAreaElement>, \"onChange\"> {\n  /**\n   * The current value of the editor\n   */\n  value: string;\n  /**\n   * Callback when the value changes\n   */\n  onChange?: (value: string) => void;\n  /**\n   * The language for syntax highlighting\n   * @default \"javascript\"\n   */\n  language?: string;\n  /**\n   * Placeholder text when the editor is empty\n   * @default \"// Write your code here...\"\n   */\n  placeholder?: string;\n  /**\n   * Whether to show line numbers\n   * @default true\n   */\n  lineNumbers?: boolean;\n  /**\n   * Whether the editor is read-only\n   * @default false\n   */\n  readOnly?: boolean;\n}\n\nconst highlighter = await createHighlighter({\n  langs: [\n    \"c\",\n    \"c++\",\n    \"javascript\",\n    \"typescript\",\n    \"jsx\",\n    \"tsx\",\n    \"html\",\n    \"css\",\n    \"json\",\n    \"markdown\",\n  ],\n  themes: [\"one-dark-pro\", \"one-light\"],\n});\n\nexport const CodeEditor = React.forwardRef<\n  HTMLTextAreaElement,\n  CodeEditorProps\n>(\n  (\n    {\n      value,\n      onChange,\n      language = \"javascript\",\n      placeholder = \"// Write your code here...\",\n      className,\n      readOnly = false,\n      ...props\n    },\n    ref,\n  ) => {\n    const [history, setHistory] = React.useState<string[]>([value || \"\"]);\n    const [historyIndex, setHistoryIndex] = React.useState(0);\n    const textareaRef = React.useRef<HTMLTextAreaElement>(null);\n    const preRef = React.useRef<HTMLPreElement>(null);\n    const combinedRef = React.useMemo(\n      () =>\n        ref\n          ? (node: HTMLTextAreaElement) => {\n              textareaRef.current = node;\n              if (typeof ref === \"function\") ref(node);\n              else if (ref) ref.current = node;\n            }\n          : textareaRef,\n      [ref],\n    );\n\n    // Handle history for undo/redo\n    const updateHistory = React.useCallback(\n      (newValue: string) => {\n        setHistory((prev) => {\n          const newHistory = prev.slice(0, historyIndex + 1);\n          newHistory.push(newValue);\n          return newHistory;\n        });\n        setHistoryIndex((prev) => prev + 1);\n      },\n      [historyIndex],\n    );\n\n    // Handle value change\n    const handleChange = React.useCallback(\n      (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n        const newValue = e.target.value;\n        onChange?.(newValue);\n        updateHistory(newValue);\n      },\n      [onChange, updateHistory],\n    );\n\n    // Handle undo/redo\n    const handleUndo = React.useCallback(() => {\n      if (historyIndex > 0) {\n        setHistoryIndex((prev) => prev - 1);\n        const previousValue = history[historyIndex - 1];\n        onChange?.(previousValue);\n      }\n    }, [history, historyIndex, onChange]);\n\n    const handleRedo = React.useCallback(() => {\n      if (historyIndex < history.length - 1) {\n        setHistoryIndex((prev) => prev + 1);\n        const nextValue = history[historyIndex + 1];\n        onChange?.(nextValue);\n      }\n    }, [history, historyIndex, onChange]);\n\n    // Handle tab key\n    const handleTab = React.useCallback(\n      (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n        if (e.key === \"Tab\") {\n          e.preventDefault();\n          const textarea = e.currentTarget;\n          const start = textarea.selectionStart;\n          const end = textarea.selectionEnd;\n          const newValue =\n            textarea.value.substring(0, start) +\n            \"  \" +\n            textarea.value.substring(end);\n          textarea.value = newValue;\n          textarea.selectionStart = textarea.selectionEnd = start + 2;\n          handleChange({\n            target: textarea,\n          } as React.ChangeEvent<HTMLTextAreaElement>);\n        }\n      },\n      [handleChange],\n    );\n\n    // Handle keyboard shortcuts\n    const handleKeyDown = React.useCallback(\n      (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n        // Tab handling\n        if (e.key === \"Tab\") {\n          handleTab(e);\n        }\n\n        // Undo/Redo\n        if ((e.metaKey || e.ctrlKey) && e.key === \"z\") {\n          e.preventDefault();\n          if (e.shiftKey) {\n            handleRedo();\n          } else {\n            handleUndo();\n          }\n        }\n\n        // Auto-pairing brackets and quotes\n        const pairs: Record<string, string> = {\n          \"(\": \")\",\n          \"{\": \"}\",\n          \"[\": \"]\",\n          \"'\": \"'\",\n          '\"': '\"',\n          \"`\": \"`\",\n        };\n\n        if (pairs[e.key]) {\n          e.preventDefault();\n          const textarea = e.currentTarget;\n          const start = textarea.selectionStart;\n          const end = textarea.selectionEnd;\n\n          if (start === end) {\n            // No selection, insert pair\n            const newValue =\n              textarea.value.substring(0, start) +\n              e.key +\n              pairs[e.key] +\n              textarea.value.substring(end);\n            textarea.value = newValue;\n            textarea.selectionStart = textarea.selectionEnd = start + 1;\n          } else {\n            // Wrap selection with pair\n            const newValue =\n              textarea.value.substring(0, start) +\n              e.key +\n              textarea.value.substring(start, end) +\n              pairs[e.key] +\n              textarea.value.substring(end);\n            textarea.value = newValue;\n            textarea.selectionStart = start + 1;\n            textarea.selectionEnd = end + 1;\n          }\n\n          handleChange({\n            target: textarea,\n          } as React.ChangeEvent<HTMLTextAreaElement>);\n        }\n      },\n      [handleChange, handleRedo, handleTab, handleUndo],\n    );\n\n    // Sync scroll between textarea and highlighted code\n    const handleScroll = React.useCallback(() => {\n      if (preRef.current && textareaRef.current) {\n        preRef.current.scrollTop = textareaRef.current.scrollTop;\n        preRef.current.scrollLeft = textareaRef.current.scrollLeft;\n      }\n    }, []);\n\n    // Generate highlighted HTML\n    const highlightedCode = React.useMemo(() => {\n      try {\n        const html = highlighter.codeToHtml(value || \"\", {\n          lang: language,\n          theme: \"one-dark-pro\",\n          colorReplacements: {\n            \"one-dark-pro\": {\n              \"#282c34\": \"transparent\",\n            },\n          },\n        });\n        return html;\n      } catch (error) {\n        console.error(\"Syntax highlighting error:\", error);\n        return `<pre>${value || \"\"}</pre>`;\n      }\n    }, [value, language]);\n\n    return (\n      <div\n        className={cn(\n          \"relative rounded-md border border-input bg-background font-mono text-sm\",\n          \"focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2\",\n          className,\n        )}\n      >\n        <div className='relative overflow-auto'>\n          <pre\n            ref={preRef}\n            className='pointer-events-none absolute h-full w-full overflow-auto whitespace-pre p-3'\n            aria-hidden='true'\n            dangerouslySetInnerHTML={{ __html: highlightedCode }}\n          />\n          <textarea\n            ref={combinedRef}\n            value={value}\n            onChange={handleChange}\n            onKeyDown={handleKeyDown}\n            onScroll={handleScroll}\n            placeholder={placeholder}\n            spellCheck='false'\n            className='h-[350px] min-h-[150px] w-full resize-y overflow-auto whitespace-pre bg-transparent p-3 font-mono text-transparent caret-foreground outline-none'\n            readOnly={readOnly}\n            {...props}\n          />\n        </div>\n      </div>\n    );\n  },\n);\nCodeEditor.displayName = \"CodeEditor\";\n",
      "type": "registry:ui"
    }
  ]
}